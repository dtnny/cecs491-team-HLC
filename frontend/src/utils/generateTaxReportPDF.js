import jsPDF from "jspdf";

/**
 * Formats a date string to a readable format
 * @param {string} dateString - ISO date string
 * @returns {string} Formatted date string
 */
function formatDate(dateString) {
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return dateString;
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  } catch (error) {
    return dateString;
  }
}

/**
 * Formats currency value
 * @param {number} amount - Amount to format
 * @returns {string} Formatted currency string
 */
function formatCurrency(amount) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
}

/**
 * Validates and sanitizes entry data
 * @param {Array} entries - Array of entry objects
 * @returns {Array} Validated and sanitized entries
 */
function validateEntries(entries) {
  if (!Array.isArray(entries)) {
    throw new Error("Entries must be an array");
  }

  return entries
    .filter((entry) => entry != null)
    .map((entry) => ({
      date: entry.date || "N/A",
      type: entry.type || "N/A",
      locationCategory: entry.locationCategory || "N/A",
      specificLocation: entry.specificLocation || "N/A",
      amount: parseFloat(entry.amount) || 0,
      result: entry.result || "unknown",
    }));
}

/**
 * Calculates statistics from entries
 * @param {Array} entries - Array of validated entries
 * @returns {Object} Statistics object
 */
function calculateStatistics(entries) {
  const wins = entries.filter((e) => e.result === "win");
  const losses = entries.filter((e) => e.result === "loss");

  // Calculate total wins (should be positive)
  const totalWin = wins.reduce((sum, e) => sum + Math.abs(e.amount), 0);
  
  // Calculate total losses
  // Handle both old format (positive losses) and new format (negative losses)
  const totalLossRaw = losses.reduce((sum, e) => {
    const amount = e.amount;
    // If amount is negative, it's already in the correct format
    // If amount is positive, it's old format and we need to make it negative
    return sum + (amount < 0 ? amount : -Math.abs(amount));
  }, 0);
  
  // For display, show losses as positive (absolute value)
  const totalLoss = Math.abs(totalLossRaw);
  
  // Net total: wins (positive) + losses (negative) = net
  const netTotal = totalWin + totalLossRaw;

  const avgWin = wins.length > 0 ? totalWin / wins.length : 0;
  const avgLoss = losses.length > 0 ? totalLoss / losses.length : 0;
  const winRate = entries.length > 0 ? (wins.length / entries.length) * 100 : 0;

  return {
    totalWin,
    totalLoss, // Display value (positive)
    netTotal,
    winCount: wins.length,
    lossCount: losses.length,
    totalEntries: entries.length,
    avgWin,
    avgLoss,
    winRate,
  };
}

/**
 * Adds page numbers to the document
 * @param {jsPDF} doc - jsPDF document instance
 */
function addPageNumbers(doc) {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(10);
    doc.setTextColor(128, 128, 128);
    doc.text(
      `Page ${i} of ${pageCount}`,
      doc.internal.pageSize.getWidth() / 2,
      doc.internal.pageSize.getHeight() - 10,
      { align: "center" }
    );
    doc.setTextColor(0, 0, 0);
  }
}

/**
 * Creates the cover page
 * @param {jsPDF} doc - jsPDF document instance
 * @param {string} year - Tax year
 * @param {string} logoBase64 - Base64 encoded logo image
 */
function createCoverPage(doc, year, logoBase64) {
  try {
    if (logoBase64) {
      doc.addImage(logoBase64, "PNG", 70, 20, 70, 70);
    }
  } catch (error) {
    console.warn("Could not add logo to PDF:", error.message);
  }

  doc.setFontSize(24);
  doc.setFont(undefined, "bold");
  doc.text("Gambling Activity Report", 105, 100, { align: "center" });

  doc.setFontSize(16);
  doc.setFont(undefined, "normal");
  doc.text(`Tax Year: ${year}`, 105, 115, { align: "center" });

  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  doc.text("Generated by GambLogic", 105, 125, { align: "center" });
  doc.text(
    `Generated on: ${new Date().toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    })}`,
    105,
    140,
    { align: "center" }
  );
  doc.setTextColor(0, 0, 0);
}

/**
 * Creates the entries pages with table layout
 * @param {jsPDF} doc - jsPDF document instance
 * @param {Array} entries - Array of validated entries
 */
function createEntriesPages(doc, entries) {
  doc.addPage();
  doc.setFontSize(16);
  doc.setFont(undefined, "bold");
  doc.text("Logbook Entries", 14, 20);

  if (entries.length === 0) {
    doc.setFontSize(12);
    doc.setFont(undefined, "normal");
    doc.text("No entries found for this period.", 14, 35);
    return;
  }

  // Table header
  doc.setFontSize(10);
  doc.setFont(undefined, "bold");
  let y = 30;
  const colWidths = [40, 35, 35, 35, 25];
  const headers = ["Date", "Type", "Category", "Location", "Amount"];
  let x = 14;

  headers.forEach((header, idx) => {
    doc.text(header, x, y);
    x += colWidths[idx];
  });

  // Draw line under header
  y += 5;
  doc.setDrawColor(200, 200, 200);
  doc.line(14, y, 200, y);
  y += 8;

  // Table rows
  doc.setFont(undefined, "normal");
  entries.forEach((entry, idx) => {
    if (y > 270) {
      doc.addPage();
      y = 20;
    }

    x = 14;
    // Display absolute value for amounts (losses are stored as negative)
    const displayAmount = entry.result === "loss" ? Math.abs(entry.amount) : entry.amount;
    const rowData = [
      formatDate(entry.date).substring(0, 10), // Truncate for space
      entry.type.substring(0, 15),
      entry.locationCategory.substring(0, 15),
      entry.specificLocation.substring(0, 15),
      formatCurrency(displayAmount),
    ];

    // Alternate row colors
    if (idx % 2 === 0) {
      doc.setFillColor(245, 245, 245);
      doc.rect(14, y - 5, 186, 7, "F");
    }

    rowData.forEach((cell, cellIdx) => {
      doc.text(cell, x, y);
      x += colWidths[cellIdx];
    });

    // Add result indicator
    doc.setFontSize(8);
    doc.setTextColor(entry.result === "win" ? 0 : 200, entry.result === "win" ? 150 : 0, 0);
    doc.text(entry.result.toUpperCase(), 180, y);
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(10);

    y += 7;
  });
}

/**
 * Creates the summary page with statistics
 * @param {jsPDF} doc - jsPDF document instance
 * @param {Object} stats - Statistics object
 * @param {string} year - Tax year
 */
function createSummaryPage(doc, stats, year) {
  doc.addPage();
  doc.setFontSize(16);
  doc.setFont(undefined, "bold");
  doc.text("Summary", 14, 20);

  doc.setFontSize(12);
  doc.setFont(undefined, "normal");
  let y = 35;

  // Summary statistics
  const summaryItems = [
    { label: "Tax Year", value: year },
    { label: "Total Entries", value: stats.totalEntries.toString() },
    { label: "Winning Entries", value: stats.winCount.toString() },
    { label: "Losing Entries", value: stats.lossCount.toString() },
    { label: "Win Rate", value: `${stats.winRate.toFixed(1)}%` },
  ];

  summaryItems.forEach((item) => {
    doc.text(`${item.label}:`, 14, y);
    doc.setFont(undefined, "bold");
    doc.text(item.value, 80, y);
    doc.setFont(undefined, "normal");
    y += 10;
  });

  y += 5;
  doc.setDrawColor(200, 200, 200);
  doc.line(14, y, 200, y);
  y += 10;

  // Financial summary
  doc.setFontSize(14);
  doc.setFont(undefined, "bold");
  doc.text("Financial Summary", 14, y);
  y += 15;

  doc.setFontSize(12);
  doc.setFont(undefined, "normal");
  doc.text("Total Winnings:", 14, y);
  doc.setFont(undefined, "bold");
  doc.setTextColor(0, 150, 0);
  doc.text(formatCurrency(stats.totalWin), 80, y);
  doc.setTextColor(0, 0, 0);
  y += 10;

  doc.setFont(undefined, "normal");
  doc.text("Total Losses:", 14, y);
  doc.setFont(undefined, "bold");
  doc.setTextColor(200, 0, 0);
  doc.text(formatCurrency(stats.totalLoss), 80, y);
  doc.setTextColor(0, 0, 0);
  y += 10;

  doc.setFont(undefined, "normal");
  doc.text("Average Win:", 14, y);
  doc.setFont(undefined, "bold");
  doc.text(formatCurrency(stats.avgWin), 80, y);
  y += 10;

  doc.setFont(undefined, "normal");
  doc.text("Average Loss:", 14, y);
  doc.setFont(undefined, "bold");
  doc.text(formatCurrency(stats.avgLoss), 80, y);
  y += 15;

  doc.setDrawColor(200, 200, 200);
  doc.line(14, y, 200, y);
  y += 10;

  // Net total (highlighted)
  doc.setFontSize(14);
  doc.setFont(undefined, "bold");
  doc.text("Net Total:", 14, y);
  doc.setFontSize(16);
  doc.setTextColor(
    stats.netTotal >= 0 ? 0 : 200,
    stats.netTotal >= 0 ? 150 : 0,
    0
  );
  doc.text(formatCurrency(stats.netTotal), 80, y);
  doc.setTextColor(0, 0, 0);
}

/**
 * Generates a tax report PDF from gambling entries
 * @param {Array} entries - Array of gambling log entries
 * @param {string} year - Tax year (e.g., "2024")
 * @param {string} logoBase64 - Base64 encoded logo image (optional)
 * @throws {Error} If entries is invalid or PDF generation fails
 */
export function generateTaxReportPDF(entries, year, logoBase64) {
  try {
    // Input validation
    if (!entries) {
      throw new Error("Entries parameter is required");
    }

    if (!year || typeof year !== "string") {
      throw new Error("Year parameter must be a valid string");
    }

    // Validate and sanitize entries
    const validatedEntries = validateEntries(entries);

    if (validatedEntries.length === 0) {
      throw new Error("No valid entries found to generate report");
    }

    // Calculate statistics
    const stats = calculateStatistics(validatedEntries);

    // Create PDF document
    const doc = new jsPDF();

    // Create cover page
    createCoverPage(doc, year, logoBase64);

    // Create entries pages
    createEntriesPages(doc, validatedEntries);

    // Create summary page
    createSummaryPage(doc, stats, year);

    // Add page numbers to all pages
    addPageNumbers(doc);

    // Save the PDF
    const fileName = `Gambling_Report_${year}.pdf`;
    doc.save(fileName);
  } catch (error) {
    console.error("Error generating tax report PDF:", error);
    throw new Error(`Failed to generate PDF: ${error.message}`);
  }
}
